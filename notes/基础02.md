### 2.认识O(NlogN)的排序
#### 2.1 使用递归求数组的最大值
```cpp
int process(const vector<int> & arr, int L, int R)
{
    if(L == R)  //base case
        return arr[L];
    int mid = L + ((R - L) >> 1);
    int leftMax = process(arr, L, mid);
    int rightMax = process(arr, mid+1, R);
    return max(leftMax, rightMax);
}
```
#### 2.2 归并排序
小和问题：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。

例：
```cpp
[1, 3, 4, 2, 5]
1: 0
3: 1
4: 1 + 3
2: 1
5: 1 + 3 + 4 + 2
all = 0 + 1 + 4 + 1 + 10 = 16
```
```cpp
int merge(vector<int> & arr, int L, int M, int R){
    vector<int> help;
    int p1 = L;
    int p2 = M + 1;
    int res = 0;
    while (p1 <= M && p2 <= R){
        res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;
        help.push_back(arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]);
    }
    while(p1 <= M){
        help.push_back(p1++);
    }
    while (p2 <= R){
        help.push_back(p2++);
    }
    for(int i = 0; i < help.size(); i++){
        arr[L + i] = help[i];
    }
    return res;
} 

int process(vector<int> & arr, int L, int R){
    if(L == R)
        return 0;
    int mid = L + ((R - L) >> 1);
    return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R);
}

int smallSum(vector<int> & arr){
    if(arr.size() < 2){
        return 0;
    }
    return process(arr, 0, arr.size() - 1);
}
```

#### 2.3 快速排序

给定一个数组arr和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求时间复杂度为O(N)，空间复杂度为O(1)。

分两种情况：

(1) arr[i] <= num，arr[i]和 <=区的下一个数交换，<=区右扩，i++

(2) arr[i] > num，i++

**荷兰国旗问题**：

给定一个数组arr和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求时间复杂度为O(N)，空间复杂度为O(1)。

分三种情况：

(1) arr[i] < num，arr[i]和 <区下一个交换，<区右扩，i++

(2) arr[i] == num，i++

(3) arr[i] > num，arr[i]和 >区前一个交换，>区左扩，i不变

#### 2.4 堆排序
小根堆

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

思路：假设k=6，准备一个小根堆，首先遍历前7个数，小根堆的最小值一定在0位置。

复杂度：O(N*logk)
```cpp
void sortedArrDistanceLessK(vector<int> & arr, int k){
    vector<int> v;
    make_heap(v.begin(), v.end(), greater<int>());
    int index = 0;
    for(; index <= min((int)arr.size(), k); index++){
        v.push_back(arr[index]);
        push_heap(v.begin(), v.end());
    }
    int i = 0;
    for(; index < arr.size(); i++, index++){
        v.push_back(arr[index]);
        push_heap(v.begin(), v.end());

        arr[i] = v[0];
        pop_heap(v.begin(), v.end());
        v.pop_back();  
    }
    while (!v.empty()){
        arr[i++] = v[0];
        pop_heap(v.begin(), v.end());
        v.pop_back();  
    }
}
```