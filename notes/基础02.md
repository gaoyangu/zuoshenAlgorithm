## 2.认识O(NlogN)的排序
[MySort.cpp](../code/MySort.cpp)

[xmind](../xmind/2.认识O(NlogN)的排序.pdf)

### 2.1 使用递归求数组的最大值
```cpp
int process(const vector<int> & arr, int L, int R){
    if(L == R)  //base case
        return arr[L];
    int mid = L + ((R - L) >> 1);
    int leftMax = process(arr, L, mid);
    int rightMax = process(arr, mid+1, R);
    return max(leftMax, rightMax);
}
```

### 2.2 归并排序
将数组分成两部分，分别进行排序，然后归并起来

```cpp
void merge(vector<int>& arr, int L, int M, int R){
    vector<int> help;   //！额外空间复杂度
    //int i = 0;
    int p1 = L;
    int p2 = M + 1;
    while (p1 <= M && p2 <= R) {
        //help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        help.push_back(arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++]);
    }
    while (p1 <= M) {
        //help[i++] = arr[p1++];
        help.push_back(arr[p1++]);
    }
    while (p2 <= R) {
        //help[i++] = arr[p2++];
        help.push_back(arr[p2++]);
    }
    for (int i = 0; i < help.size(); i++) {
        arr[L + i] = help[i];
    }
}
void process(vector<int>& arr, int L, int R){
    if (L == R){
        return;
    }
    int mid = L + ((R - L) >> 1);
    process(arr, L, mid);
    process(arr, mid + 1, R);
    merge(arr, L, mid, R);
}
void mergeSort(vector<int> & arr){
    if(arr.size() < 2){
        return;
    }
    process(arr, 0, arr.size() - 1);
}
```

小和问题：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。

例：
```cpp
[1, 3, 4, 2, 5]
1: 0
3: 1
4: 1 + 3
2: 1
5: 1 + 3 + 4 + 2
all = 0 + 1 + 4 + 1 + 10 = 16
```
```cpp
int merge(vector<int> & arr, int L, int M, int R){
    vector<int> help;
    int p1 = L;
    int p2 = M + 1;
    int res = 0;
    while (p1 <= M && p2 <= R){
        res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;
        help.push_back(arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]);
    }
    while(p1 <= M){
        help.push_back(p1++);
    }
    while (p2 <= R){
        help.push_back(p2++);
    }
    for(int i = 0; i < help.size(); i++){
        arr[L + i] = help[i];
    }
    return res;
} 
int process(vector<int> & arr, int L, int R){
    if(L == R){
        return 0;
    }       
    int mid = L + ((R - L) >> 1);
    return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R);
}
int smallSum(vector<int> & arr){
    if(arr.size() < 2){
        return 0;
    }
    return process(arr, 0, arr.size() - 1);
}
```

### 2.3 快速排序

给定一个数组arr和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求时间复杂度为O(N)，空间复杂度为O(1)。

分两种情况：

(1) arr[i] <= num，arr[i]和 <=区的下一个数交换，<=区右扩，i++

(2) arr[i] > num，i++

```cpp
vector<int> partition1(vector<int> & arr, int num){
    int less = -1;          // <区右边界
    int more = arr.size();  // >区左边界
    while (L < more){
        if(arr[L] <= num){        //当前值 < 划分值
            swap(arr, ++less, L++);
        }else if(arr[L] > num){  //当前值 > 划分值
            L++;
        }
    }
    return {less + 1, more};
}
```

**荷兰国旗问题**：

给定一个数组arr和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求时间复杂度为O(N)，空间复杂度为O(1)。

分三种情况：

(1) arr[i] < num，arr[i]和 <区下一个交换，<区右扩，i++

(2) arr[i] == num，i++

(3) arr[i] > num，arr[i]和 >区前一个交换，>区左扩，i不变

```cpp
vector<int> partition2(vector<int> & arr, int num){
    int less = -1;          // <区右边界
    int more = arr.size();  // >区左边界
    while (L < more){
        if(arr[L] < num){        //当前值 < 划分值
            swap(arr, ++less, L++);
        }else if(arr[L] > num){  //当前值 > 划分值
            swap(arr, --more, L);
        }else{
            L++;
        }
    }
    return {less + 1, more};
}
```

**快速排序**：

1.0版本：把最后一个数作为划分值num，<=num的放在左边，>num的放在右边，将num与>num区域的第一个数做交换，左右分别递归

2.0版本：把最后一个数作为划分值num，<num的放在左边，=num的放中间，>num的放在右边，将num与>num区域的第一个数做交换，左右分别递归

3.0版本：在数组中随机选择一个数，与最后一个数交换作为划分值num

```cpp
//返回值：等于区域的左边界和右边界
vector<int> partition(vector<int> & arr, int L, int R){
    int less = L - 1;   // <区右边界
    int more = R;       // >区左边界
    while (L < more){
        if(arr[L] < arr[R]){        //当前值 < 划分值
            swap(arr, ++less, L++);
        }else if(arr[L] > arr[R]){  //当前值 > 划分值
            swap(arr, --more, L);
        }else{
            L++;
        }
    }
    swap(arr, more, R);
    return {less + 1, more};
}
void quickSort(vector<int> & arr, int L, int R){
    if(L < R){
        swap(arr, L + (rand()%(R - L + 1)) + 1, R); //在数组中随机选择一个数，与最后一个数交换作为划分值num
        vector<int> p = partition(arr, L, R);   //根据实际的数据状况决定
        quickSort(arr, L, p[0] - 1);
        quickSort(arr, p[1] + 1, R);
    }
}
```

### 2.4 堆排序

**大根堆**

```cpp
// 某个数现在处在index位置，往上继续移动
void heapInsert(vector<int> & arr, int index){
    while (arr[index] > arr[(index - 1) / 2]){  //当前的数大于父位置的数
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}
//某个数在index位置，能否往下移动
void heapify(vector<int> & arr, int index, int heapSize){
    int left = index * 2 + 1;   //左孩子的下标
    while (left < heapSize){
        //两个孩子中，谁的值大，把下标给largest
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        //父和较大的孩子之间，谁的值大，把下标给largest
        largest = arr[largest] > arr[index] ? largest : index;
        if(largest == index){
            break;
        }
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

**堆排序**

```cpp
void heapSort(vector<int> & arr){
    if(arr.size() < 2){
        return;
    }
    // 用户一次只给一个数: O(NlogN)
    for (int i = 0; i < arr.size(); i++){   //O(N)
        heapInsert(arr, i); //O(logN)
    }
    // 用户一次给出所有的数: O(N)
    // for (int i = arr.size() - 1; i >= 0; i--){
    //     heapify(arr, i, arr.size());
    // }
    int heapSize = arr.size();
    swap(arr, 0, --heapSize);       //0位置的数与堆上最后一个数做交换
    while (heapSize > 0){           //O(N)
        heapify(arr, 0, heapSize);  //O(logN)
        swap(arr, 0, --heapSize);   //O(1)
    }
}
```

**小根堆**

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

思路：假设k=6，准备一个小根堆，首先遍历前7个数，小根堆的最小值一定在0位置。

复杂度：O(N*logk)
```cpp
void sortedArrDistanceLessK(vector<int> & arr, int k){
    priority_queue<int> q;
    int index = 0;
    for(; index <= min((int)arr.size(), k); index++){
        q.push(arr[index]);
    }
    int i = 0;
    for(; index < arr.size(); i++, index++){
        q.push(arr[index]);
        arr[i] = q.top();
        q.pop();
    }
    while (!q.empty()){
        arr[i++] = q.top();
        q.pop();
    }
}
```