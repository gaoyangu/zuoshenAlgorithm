### 7. 前缀树和贪心算法
[MyTire.cpp](../code/MyTire.cpp)

#### 7.1 前缀树

**1. 例子**

一个字符串类型的数组arr1，另一个字符串类型的数组arr2。arr2中有哪些字符，是arr1中出现的？请打印。arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印。请打印 arr2中出现次数最大的前缀。

```cpp
class TireNode{
public:
    TireNode(){
        pass = 0;
        end = 0;
        for(int i = 0; i < 26; i++){
            // next[0] == nullptr   没有走向'a'的路
            // next[0] != nullptr   有走向'a'的路
            // ...
            // next[25] != nullptr   有走向'z'的路
            nexts.push_back(nullptr);
        }
    }

    int pass;
    int end;
    vector<TireNode*> nexts;
};

class Tire{
public:
    Tire(){
        root = new TireNode();
    }

    TireNode* root;

    void insertWord(string word){
        if(vord == null){
            return;
        }
        TireNode* node = root;
        node->pass++;
        int index = 0;
        for(auto ch : word){
            index = ch - 'a';
            if(node->nexts[index] == nullptr){
                node->nexts[index] = new TireNode();
            }
            node = node->nexts[index];
            node->pass++;
        }
        node->end++;
    }

    // word 这个单词之前加入过了几次
    int searchWord(string word){
        if(word == null){
            return 0;
        }
        TireNode* node = root;
        int index = 0;
        for(auto ch : word){
            index = ch - 'a';
            if(node->nexts[index] == nullptr){
                return 0;
            }
            node = node->nexts[index];
        }
        return node->end;
    }

    // 所有加入的字符串中，有几个是以 pre 这个字符串作为前缀的
    int prefixNumber(string pre){
        if(pre == null){
            return 0;
        }
        TireNode* node = root;
        int index = 0;
        for(auto ch : pre){
            index = ch - 'a';
            if(node->nexts[index] == nullptr){
                return 0;
            }
            node = node->nexts[index];
        }
        return node->pass;
    }

    void deleteWord(string word){
        if(searchWord(word) != 0){
            TireNode* node = root;
            node->pass--;
            int index = 0;
            for(auto ch : word){
                index = ch - 'a';
                if(--node->nexts[index]->pass == 0){
                    node->nexts[index] = nullptr;   // todo
                    return;
                }
                node = node->nextsp[index];
            }
            node->end--;
        }
    }
};
```

#### 7.2 贪心算法

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。

也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。

局部最优 -？-> 整体最优 

**1. 会议安排**

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。

给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。

返回这个最多的宣讲场次。

[贪心策略] 哪个会议结束时间早就先安排

```cpp
class Program{
public:
    Program(int s, int e) : start(s), end(e) { }

    int start;
    int end;
};
// 谓词
class ProgramComparator{
public:
    bool operator()(Program & p1, Program & p2){
        return p1.end < p2.end;
    }
};
int bestArrange(vector<Program*> & programs, int timePoint){
    sort(programs.begin(), programs.end(), ProgramComparator());
    int result = 0;
    for(int i = 0; i < programs.size(); i++){
        if(timePoint <= programs[i]->start){
            result++;
            timePoint = programs[i]->end;
        }
    }
    return result;
}
```

**2. 贪心算法的笔试解题套路**

1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试

2，脑补出贪心策略A、贪心策略B、贪心策略C.

3，用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确

4，不要去纠结贪心策略的证明

**3. 贪心算法证明**

一个有很多字符串的数组, 决定一种字符串的拼接顺序, 将数组中的字符串全部拼接起来, 如何让最后拼接成的字符串保证最小的字典序

[贪心策略] a.b ≤ b.a ? a.b : b.a;

```cpp
class MyComparator{
public:
    bool operator()(string & p1, string & p2){
        return p1 < p2;
    }
};
string lowestString(vector<string> & strs){
    if(strs.size() < 1){
        return "";
    }
    sort(strs.begin(), strs.end(), MyComparator());
    string res;
    for(int i = 0; i < strs.size(); i++){
        res += strs[i];
    }
    return res;
}
```

**4. 贪心策略在实现时，经常使用的技巧**

1，根据某标准建立一个比较器来排序

2，根据某标准建立一个比较器来组成堆

**5. 分金条**

一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。

一群人想整分整块金条，怎么分最省铜板？

例如，给定数组｛10，20，30］，代表一共三个人，整块金条长度为10＋20＋30＝60。金条要分成10，20，30三个部分。如果先把长度60的金条分成10和50，花费60；再把长度50的金条分成20和30，花费50；一共花费110铜板。

但是如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20，花费30；一共花费90铜板。

输入一个数组，返回分割的最小代价。

[提示] 哈夫曼编码问题

✅tested
```cpp
int lessMoney(vector<int>& arr) {
    // 小根堆
    priority_queue<int, vector<int>, greater<int>> pQ(arr.begin(), arr.end());
    int sum = 0;
    int cur = 0;
    while (pQ.size() > 1) {
        int cur1 = pQ.top();
        pQ.pop();
        cout << cur1 << endl;

        int cur2 = pQ.top();
        pQ.pop();
        cout << cur2 << endl;

        cur = cur1 + cur2;
        sum += cur;
        pQ.push(cur);
    }
    return sum;
}
```

**6. 做任务，得利润**

[输入]：

正数数组costs, 正数数组profits, 正数k, 正数m 

[含义]：

costs[i] 表示i号项目的花费

profits[i] 表示i号项目在扣除花费之后还能挣到的钱（利润）

k 表示你只能串行的最多做k个项目

m 表示初始的资金 

[说明]：

你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。

[输出]：

你最后获得的最大钱数。

✅tested
```cpp
class Node {
public:
    Node(int p, int c) : profit(p), cost(c){ }
    int profit;
    int cost;
};
class MinCostComparator {
public:
    bool operator()(Node* o1, Node* o2) {
        return o1->cost > o2->cost;
    }
};
class MinProfitComparator {
public:
    bool operator()(Node* o1, Node* o2) {
        return o1->profit < o2->profit;
    }
};
// k: 最多做k个项目，w: 初始资金
int findMaxCapital(int k, int w, vector<int>& Profits, vector<int>& Capital) {
    priority_queue<Node*, vector<Node*>, MinCostComparator> minCostQ;
    priority_queue<Node*, vector<Node*>, MinProfitComparator> maxProfitQ;
    // 所有项目放在被锁池中，根据 cost 组织的小根堆
    for (int i = 0; i < Profits.size(); i++) {
        minCostQ.push(new Node(Profits[i], Capital[i]));
    }
    for (int i = 0; i < k; i++) {
        // 能力所及的项目，全解锁
        while (!minCostQ.empty() && minCostQ.top()->cost <= w) {
            maxProfitQ.push(minCostQ.top());
            minCostQ.pop();
        }
        if (maxProfitQ.empty()) {
            return w;
        }
        w += maxProfitQ.top()->profit;
        maxProfitQ.pop();
    }
    return w;
}
```

#### 7.3 堆的应用

一个数据流中，随时可以取得中位数

[提示] 大根堆与小根堆的配合

```cpp
(1) 第一个数字入大根堆，
(2) cur <= 大根堆堆顶 ? cur入大根堆 : cur入小根堆;
(3) 比较大根堆和小根堆的size, 当两者的size相差2时, size较大者的堆顶入另一个堆 
```
效果：较小的一半数在大根堆中，较大的一半数在小根堆中

- [ ] code

#### 7.4 N皇后问题

N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。

给定一个整数n，返回n皇后的摆法有多少种。

n＝1，返回1。

n＝2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。

n＝8，返回92。

[时间复杂度]： O(n!)
```cpp
bool isVaild(vector<int>& record, int i, int j) {
    for (int k = 0; k < i; k++) {
        if (j == record[k] || abs(record[k] - j) == abs(i - k)) {
            return false;
        }
    }
    return true;
}
// record[0,...,i-1] 的皇后，任何两个皇后一定不共行、不共列、不共斜线
// 目前来到了第 i 行
// record[0,...,i-1] 表示之前的行，放过了哪些皇后
// n 代表整体一共有多少行
// res 表示摆完所有的皇后，合理的摆法有多少种
int process1(int i, vector<int> & record, int n){
    if (i == n) {   // 终止行：最后一行再下一行的位置
        return 1;
    }
    int res = 0;
    for (int j = 0; j < n; j++) {
        // 当前i行的皇后，放在j列，会不会和之前(0...i-1)的皇后共行、共列或共斜线
        if (isVaild(record, i, j)) {
            record[i] = j;
            res += process1(i + 1, record, n);
        }
    }
    return res;
}
int num1(int n) {
    if (n < 1) {
        return 0;
    }
    vector<int> record; // record[i] -> 第i行的皇后，放在了第几列
    return process1(0, record, n);
}
```

- 常数时间的优化，使用位运算
```cpp
// colLim 列的限制，1的位置不能放皇后，0的位置可以
// leftDiaLim 左斜线的限制
// rightDiaLim 右斜线的限制
int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim) {
    if (colLim == limit) {  // base case
        return 1;
    }
    int pos = 0;
    int mostRightOne = 0;
    // 所有候选皇后的位置都在pos上
    pos = limit & (~(colLim | rightDiaLim | leftDiaLim));
    int res = 0;
    while (pos != 0) {
        mostRightOne = pos & (~pos + 1);
        pos = pos - mostRightOne;
        res += process2(limit,
                        colLim | mostRightOne, 
                        (leftDiaLim | mostRightOne) << 1, 
                        (rightDiaLim | mostRightOne) >> 1);
    }
    return res;
}
// 请不要超过32皇后问题
int num2(int n) {
    if (n < 1 || n > 32) {
        return 0;
    }
    // 生成二进制的数，8皇后问题，后8为是1
    int limit = n == 32 ? -1 : (1 << n) - 1;
    return process2(limit, 0, 0, 0);
}
```
