## 1.认识复杂度和简单排序算法
[MybinarySearch.cpp](../code/MybinarySearch.cpp)

[xmind](../xmind/1.认识复杂度和简单排序算法.pdf)

### 1.0 时间复杂度和额外空间复杂度

### 1.1 异或运算
- 在一个整型数组中，只有一种数出现了奇数次，其他数都出现了偶数次，如何找到这一种数。
```cpp
void printOddTimesNum1(vector<int> & arr){
    int eor = 0;
    for(int cur : arr)
        eor ^= cur;
    cout << eor << endl;
}
```
- 有两种数出现了奇数次，其他数都出现了偶数次，如何找到这两种数。
```cpp
void printOddTimesNum2(vector<int> & arr){
    int eor = 0;
    for(int cur : arr){
        eor ^= cur;
    }      
    // eor = a^b;
    // eor != 0;    -->    eor 必然有一个位置上是1
    int rightOne = eor & (~eor + 1);    //提取出最右侧的1
    int onlyOne = 0;    // eor'
    for(int cur : arr){
        if(cur & rightOne == 0){
            onlyOne ^= cur;
        }   
    }
    cout << onlyOne << ", " << (eor ^ onlyOne) << endl;  
}
```

### 1.2 选择排序
从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到整个数组排序。

```cpp
void selectionSort(vector<int> & arr){
    if( arr.size() < 2){
        return;
    }
    for (int i = 0; i < arr.size() - 1; i++){
        int minIndex = i;
        for (int j = i + 1; j < arr.size(); j++){
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i ,minIndex);
    }
}
```
### 1.3 冒泡排序
从左到右不断交换相邻逆序的元素，在一轮循环之后，可以让未排序的最大元素上浮到右侧。

```cpp
void bubbleSort(vector<int> & arr){
    if( arr.size() < 2){
        return;
    } 
    for(int i = arr.size() - 1; i > 0; i--){
        for (int j = 0; j < i; j++){
            if(arr[j] > arr[j+1]){
                swap(arr, j, j+1);  
            }    
        }
    }
}
```

### 1.4 插入排序
每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

```cpp
void insertionSor(vector<int> & arr){
    if (arr.size() < 2){
        return;
    }
    for(int i = 1; i < arr.size(); i++){ //0~i做到有序
        for(int j = i-1; j >= 0 && arr[j] > arr[j+1]; j--){ // 0~i-1 已经有序, j 当前位置的前一个位置
            swap(arr, j, j+1);
        }
    }
}
```

### 1.5 二分法
- 一个有序数组，寻找某个数num是否存在。
```cpp
int binarySearch(const vector<int> & arr, const int & num){
    int low = 0;
    int high = arr.size() - 1;
    while (low < high){
        //int mid = (low + high) / 2; 
        int mid = low + ((high - low) >> 1);
        if(arr[mid] < num){
            low = mid + 1;
        }       
        else if(arr[mid] > num){
            high = mid - 1;
        }
        else{
            return mid; // find
        }     
    }
    return -1;  //not found
}
```
- 在一个有序数组中，找>=某个数num最左侧的位置。
```cpp
int binarySearch_01(const vector<int> & arr, const int & num){
    int low = 0;
    int high = arr.size() - 1;
    int index = -1;
    while (low <= high){
        //int mid = (low + high) / 2; 
        int mid = low + ((high - low) >> 1);
        if(arr[mid] >= num){
            index = mid;
            high = mid - 1;
        }
        else if(arr[mid] < num){
            low = mid + 1;
        }  
    }
    return index;
}
```
- 数组无序，任何两个相邻数一定不相等，求局部最小值
```cpp
int binarySearch_02(const vector<int> & arr){
    if(arr.size() < 2)
        return -1; 
    int low = 0;
    int high = arr.size() - 1;

    //如果端点处为局部最小值
    if(arr[0] < arr[1]){
        return 0;
    }
    else if(arr[arr.size() - 1] < arr[arr.size() - 2]){
        return arr.size() - 1;
    }
    while (low < high){
        //int mid = (low + high) / 2; 
        int mid = low + ((high - low) >> 1);
        //判断 mid 处是否为局部最小值
        if(arr[mid] < arr[mid + 1] && arr[mid] < arr[mid - 1]){
            return mid;
        }
        else if(arr[mid] > arr[mid + 1]){
            low = mid + 1;
        }
        else if(arr[mid] > arr[mid - 1]){
            high = mid - 1;
        }  
    }
}
```

### 1.6 对数器

1. 有一个你想要测得方法a
2. 实现复杂度不好但是容易实现的方法b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同得随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得对比结果不一致，打印样本进行人工干预，改对方法a或者方法b
6. 当样本数量很多时，比对测试依然正确，可以确定方法a正确
