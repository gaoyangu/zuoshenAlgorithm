### 6. 图
[MyGraph.cpp](../code/MyGraph.cpp)

图的存储方式：
- 邻接表
- 邻接矩阵

表达图的方式有很多：

[提示] 把图按照习惯表达图的方式将所有的算法实现一遍，然后将给定的图结构，转换为习惯使用的图结构

#### 6.1 图的结构
```cpp
class Node{
public:
    Node(int val, int i = 0, int o = 0) : value(val), in(i), out(o) { }

    int value;
    int in;     // 节点的入度
    int out;    // 节点的出度
    vector<Node*> nexts;
    vector<Edge*> edges;
};

class Edge{
public:
    Edge(int w, Node* f, Node* t) : weight(w), from(f), to(t) { }

    int weight;
    Node* from;
    Node* to;
};

class Graph{
public:
    unordered_map<int, Node*> nodes;
    unordered_set<Edge*> edges;
};
```

#### 6.2 图的宽度优先遍历
1，利用队列实现

2，从源节点开始依次按照宽度进队列，然后弹出

3，每弹出一个点，把该节点所有没有进过队列的邻接点放入队列

4，直到队列变空

```cpp
void bfs(Node* node){
    if(node == nullptr){
        return;
    }
    queue<Node*> q;
    unordered_set<Node*> s; // 保证不要重复进队列
    q.push(node);
    s.insert(node);
    while (!q.empty()){
        Node* cur = q.front();
        q.pop();
        cout << cur->value << " ";
        for(Node* next : cur->nexts){
            if(s.find(next) == s.end()){
                s.insert(next);
                q.push(next);
            }
        }
    }
}
```

#### 6.3 图的深度优先遍历

1，利用栈实现

2，从源节点开始把节点按照深度放入栈，然后弹出

3，每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈

4，直到栈变空

```cpp
void dfs(Node* node){
    if(node == nullptr){
        return;
    }
    stack<Node*> sT;
    unordered_set<Node*> s;
    sT.push(node);
    s.insert(node);
    cout << node->value << " ";
    while (!sT.empty()){
        Node* cur = sT.top();
        sT.pop();
        for(Node* next : cur->nexts){
            if(s.find(next) == s.end()){
                s.insert(cur);
                s.insert(next);
                cout << next->value << " ";
                break;
            }
        }
    }
}
```

#### 6.4 拓扑排序算法

[应用场景] 代码的编译顺序(文件之间的依赖关系)

[适用范围] 要求有向图，且有入度为0的节点，且没有环

```cpp
list<Node*> sortedTopology(Graph graph){
    // key: 某一个node
    // value: 剩余的入度
    unordered_map<Node*, int> inMap;
    // 入度为0的点，才能进这个队列
    queue<Node*> zeroInQueue;
    for(int i = 0; i < graph.nodes.size(); i++){
        Node* node = graph.nodes.at(i);
        inMap.insert(pair<Node*, int>(node, node->in));
        if(node->in == 0){
            zeroInQueue.push(node);
        }
    }
    // 拓扑排序的结果，依次加入result
    list<Node*> result;
    while (!zeroInQueue.empty()){
        Node* cur = zeroInQueue.front();
        zeroInQueue.pop();
        result.push_back(cur);
        for(Node* next : cur->nexts){
            inMap.insert(pair<Node*, int>(next, inMap.at(next) - 1));
            if(inMap.at(next) == 0){
                zeroInQueue.push(next);
            }
        }
    }
    return result;
}
```

#### 6.5 最小生成树

既保证连通性，也保证所有边的权值最小

- [ ] 并查集

**1. kruskal算法**

[适用范围] 无向图

以边的角度出发，将所有的边排序，从最小的边开始考虑，判断加上这个边有没有形成环，形成环就不加

```cpp
class MySets{
public:
    MySets(list<Node*> nodes){
        for(Node* cur : nodes){
            list<Node*> s;
            s.push_back(cur);
            setMap.insert(pair<Node*, list<Node*>>(cur, s));
        }
    }

    bool isSameSet(Node* from, Node* to){
        list<Node*> fromSet = setMap.at(from);
        list<Node*> toSet = setMap.at(to);
        return fromSet == toSet;
    }

    void unionSet(Node* from, Node* to){
        list<Node*> fromSet = setMap.at(from);
        list<Node*> toSet = setMap.at(to);
        for(Node* toNode : toSet){
            fromSet.push_back(toNode);
            setMap.insert(pair<Node*, list<Node*>>(toNode, fromSet));
        }
    }

    unordered_map<Node*, list<Node*>> setMap;
};
// kruskal算法
class EdgeComparator{
public:
    bool operator()(Edge* e1, Edge* e2){
        return e1->weight > e2->weight;
    }
};
set<Edge*> kruskalMST(Graph graph){
    list<Node*> ltmp;
    for(int i = 0; i < graph.nodes.size(); i++){
        ltmp.push_back(graph.nodes.at(i));
    }
    MySets mysets(ltmp);
    vector<Edge*> v;
    for(Edge* edge : graph.edges){
        v.push_back(edge);
    }
    make_heap(v.begin(), v.end(), EdgeComparator());
    set<Edge*> result;
    while(!v.empty()){
        pop_heap(v.begin(), v.end(), EdgeComparator());
        Edge* e = v.back();
        v.pop_back();
        if(!mysets.isSameSet(e->from, e->to)){
            result.insert(e);
            mysets.unionSet(e->from, e->to);
        }
    }
    return result;
}
```

**2. prim算法**

[适用范围] 无向图

从点的角度出发，从任意点出发

```cpp
set<Edge*> primMST(Graph graph){
    vector<Edge*> v;
    vector<Node*> vN;
    unordered_set<Node*> s;
    set<Edge*> result;      // 依次挑选的边放在result中
    for(int i = 0; i < graph.nodes.size(); i++){
        vN.push_back(graph.nodes.at(i));
    }
    for(Node* node : vN){   // 随便挑一个点
        if(s.find(node) == s.end()){
            s.insert(node);
            for(Edge* edge : node->edges){  // 由一个点，解锁所有相连的边
                v.push_back(edge);
            }
            make_heap(v.begin(), v.end(), EdgeComparator());
            while(!v.empty()){
                pop_heap(v.begin(), v.end(), EdgeComparator());
                Edge* edge = v.back();  // 弹出解锁的边中最小的边
                v.pop_back();
                Node* toNode = edge->to;    // 可能的一个新的点
                if(s.find(toNode) == s.end()){  // 不包含的时候就是新的点
                    s.insert(toNode);
                    result.insert(edge);
                    for(Edge* newEdge : toNode->edges){
                        v.push_back(newEdge);
                        make_heap(v.begin(), v.end(), EdgeComparator());
                    }
                }
            }
        }
    }
    return result;
}
```

#### 6.6 Dijkstra算法

[适用范围] 可以有权值为负数的边，不能出现累加和为负数的环

```cpp
Node* getMinDistanceAndUnselectedNode(
        unordered_map<Node*, int> distaceMap, 
        unordered_set<Node*> touchedNodes){
    Node* minNode;
    int minDistance = INTMAX_MAX;
    for(pair<Node*, int> entry : distaceMap){
        Node* node = entry.first;
        int distance = entry.second;
        if(touchedNodes.find(node) == touchedNodes.end() && distance < minDistance){
            minNode = node;
            minDistance = distance;
        }
    }
    return minNode;
}
unordered_map<Node*, int> dijkstral(Node* head){
    // key: 从head出发到达key
    // value: 从head出发到达key的最小距离
    unordered_map<Node*, int> distanceMap;
    distanceMap.insert(pair<Node*, int>(head, 0));
    // 已经求过距离的节点放在selectedNodes中，以后再也不碰
    unordered_set<Node*> selectedNodes;
    Node* minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    while (minNode != nullptr){
        int distance = distanceMap.at(minNode);
        for(Edge* edge : minNode->edges){
            Node* toNode = edge->to;
            if(distanceMap.find(toNode) == distanceMap.end()){
                distanceMap.insert(pair<Node*, int>(toNode, distance + edge->weight));
            }
            distanceMap.insert(pair<Node*, int>(toNode, min(distanceMap.at(toNode), distance + edge->weight)));
        }
        selectedNodes.insert(minNode);
        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    }
    return distanceMap;
}
```

- [x] 使用堆的改写

```cpp
class NodeRecord{
public:
    NodeRecord(Node* n, int dis) : node(n), distance(dis) {}
    Node* node;
    int distance;
};
class NodeHeap{
public:
    NodeHeap(int s) : size(0) {}

    bool isEmpty(){
        return size == 0;
    }
    bool isEntered(Node* node){
        return heapIndexMap.find(node) != heapIndexMap.end();
    }
    bool inHeap(Node* node){
        return isEntered(node) && heapIndexMap.at(node) != -1;
    }
    void swap(int index1, int index2){
        heapIndexMap.at(nodes[index1]) = index2;
        heapIndexMap.at(nodes[index2]) = index1;
        Node* tmp = nodes[index1];
        nodes[index1] = nodes[index2];
        nodes[index2] = tmp;
    }
    void insertHeapify(Node* node, int index){
        while (distanceMap.at(nodes[index]) < distanceMap.at(nodes[(index - 1)/2])){
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }
    void heapify(int index, int size){
        int left = index * 2 + 1;
        while (left < size){
            int smallest = left + 1 < size && distanceMap.at(nodes[left + 1]) < distanceMap.at(nodes[left]) ? left + 1 : left;
            smallest = distanceMap.at(nodes[smallest]) < distanceMap.at(nodes[index]) ? smallest : index;
            if(smallest == index){
                break;
            }
            swap(smallest, index);
            index = smallest;
            left = index * 2 + 1;
        }
    }
    void addOrUpdateOrIgnore(Node* node, int distance){ 
        if(inHeap(node)){
            distanceMap.at(node) = min(distanceMap.at(node), distance);
            insertHeapify(node, heapIndexMap.at(node));
        }
        if(!isEntered(node)){
            nodes[size] = node;
            heapIndexMap.at(node) = size;
            distanceMap.at(node) = distance;
            insertHeapify(node, size++);
        }
    }
    NodeRecord* pop(){
        NodeRecord* nodeRecord = new NodeRecord(nodes[0], distanceMap.at(nodes[0]));
        swap(0, size - 1);
        heapIndexMap.at(nodes[size - 1]) = -1;
        distanceMap.erase(nodes[size - 1]);
        nodes.erase(nodes.begin() + size - 1);
        heapify(0, --size);
        return nodeRecord;
    }

    vector<Node*> nodes;
    unordered_map<Node*, int> heapIndexMap;
    unordered_map<Node*, int> distanceMap;
    int size;
};
unordered_map<Node*, int> dijkstral2(Node* head, int size){
    NodeHeap* nodeheap = new NodeHeap(size);
    nodeheap->addOrUpdateOrIgnore(head, 0);
    unordered_map<Node*, int> result;
    while(!nodeheap->isEmpty()){
        NodeRecord* record = nodeheap->pop();
        Node* cur = record->node;
        int distance = record->distance;
        for(Edge* edge : cur->edges){
            nodeheap->addOrUpdateOrIgnore(edge->to, edge->weight + distance);
        }
        result.insert(pair<Node*, int>(cur, distance));
    }
    return result;
}
```