## 5. 二叉树
[MybinaryTree.cpp](../code/MybinaryTree.cpp)
### 5.1 二叉树节点结构

```cpp
class Node{
    int value;
    Node* left;
    Node* right;
};
```
### 5.2 使用递归和非递归两种方式实现二叉树的先序、中序、后序遍历

**1. 递归序**

递归方法完成二叉树的遍历，每个节点都能回到三次。
```cpp
void f(Node* head){
    // 1
    if(head == nullptr){
        return;
    }
    // 1：第一次回到自己
    f(head->left);
    // 2
    // 2：第二次回到自己
    f(head->right);
    // 3
    // 3：第三次回到自己
}
```
- 先序
```cpp
void preOrderRecur(Node* head){
    if(head == nullptr){
        return;
    }
    cout << head->value << " ";
    preOrderRecur(head->left);
    preOrderRecur(head->right);
}
```
- 中序
```cpp
void inOrderRecur(Node* head){
    if(head == nullptr){
        return;
    }
    inOrderRecur(head->left);
    cout << head->value << " ";
    inOrderRecur(head->right);
}
```
- 后序
```cpp
void posOrderRecur(Node* head){
    if(head == nullptr){
        return;
    }
    posOrderRecur(head->left);
    posOrderRecur(head->right);
    cout << head->value << " ";
}
```

**2. 非递归方法**
- 先序（深度优先遍历）
    - 先把头节点 head 放到栈中
    - (1) 从栈中弹出一个节点 cur
    - (2) 打印/处理 cur
    - (3) 先压右再压左 (没有就什么也不做)
    - (4) 循环
```cpp
void preOrderUnRecur(Node* head){
    if(head != nullptr){
        stack<Node*> s;
        s.push(head);
        while (!s.empty()){
            head = s.top();
            s.pop();
            cout << head->value << " ";
            if(head->right != nullptr){
                s.push(head->right);
            }
            if(head->left != nullptr){
                s.push(head->left);
            }
        }
    }
}
```
- 后序 (将先序遍历加工)
    - 先序' (头右左)
    - 先把头节点 head 放到栈中
    - (1) 从栈中弹出一个节点 cur
    - (2) cur 放到收集栈中
    - (3) 先压左再压右 (没有就什么也不做)
    - (4) 循环
```cpp
void posOrderUnRecur(Node* head){
    if(head != nullptr){
        stack<Node*> s1;
        stack<Node*> s2;
        s1.push(head);
        while (!s1.empty()){
            head = s1.top();
            s1.pop();
            s2.push(head);
            if(head->left != nullptr){
                s1.push(head->left);
            }
            if(head->right != nullptr){
                s1.push(head->right);
            }
        }
        while(!s2.empty()){
            cout << s2.top()->value << " ";
            s2.pop();
        }
    }
}
```
- 中序
    - 整棵树左边界进栈
    - 依次弹出过程中打印
    - 对弹出节点的右树重复
```cpp
void inOrderUnRecur(Node* head){
    if(head != nullptr){
        stack<Node*> s;
        while (!s.empty() || head != nullptr){
            if(head != nullptr){
                s.push(head->left);
                head = head->left;
            }
            else{
                head = s.top();
                s.pop();
                cout << head->value << " ";
                head = head->right;
            }
        }
    }
}
```

### 5.3 如何完成二叉树的宽度优先遍历

宽度优先遍历用 `队列`，弹出就打印，先放左再放右
```cpp
void w(Node* head){
    if(head == nullptr){
        return;
    }
    queue<Node*> q;
    q.push(head);
    while (!q.empty()){
        Node* cur = q.front();
        q.pop();
        cout << cur->value;
        if(cur->left != nullptr){
            q.push(cur->left);
        }
        if(cur->right != nullptr){
            q.push(cur->right);
        }
    }
}
```

常见题目：求一颗二叉树的宽度
- [ ] 不使用哈希表的方法
```cpp
int getMaxWidth(Node* head){
    if(head == nullptr){
        return 0;
    }
    int maxWidth = 0;
    int curWidth = 0;
    int curLevel = 0;
    unordered_map<Node*, int> levelMap;
    levelMap.insert(pair<Node*, int>(head, 1));
    queue<Node*> q;
    q.push(head);
    Node* node = nullptr;
    Node* left = nullptr;
    Node* right = nullptr;
    while (!q.empty()){
        node = q.front();
        left = node->left;
        right = node->right;
        q.pop();
        int curLevelNodes = levelMap.at(node);
        if(curLevelNodes == curLevel){
            curWidth++;
        }
        else{
            maxWidth = max(maxWidth, curWidth);
            curLevel++;
            curLevelNodes = 1;
        }
        if(left != nullptr){
            levelMap.insert(pair<Node*, int>(left, levelMap.at(node) + 1));
            q.push(left);
        }
        if(right != nullptr){
            levelMap.insert(pair<Node*, int>(right, levelMap.at(node) + 1));
            q.push(right);
        }
    }
    return maxWidth;
}
```

### 5.4 二叉树的相关概念及其实现判断

**1. 如何判断一颗二叉树是否是搜索二叉树**

[提示] 中序遍历

- [ ] 递归套路解法

```cpp
// 递归
int preValue = INTMAX_MIN;
bool checkBST(Node* head){
    if(head == nullptr){
        return true;
    }
    bool isLeftBST = checkBST(head->left);
    if(!isLeftBST){
        return false;
    }
    if(head->value <= preValue){
        return false;
    }
    else{
        preValue = head->value;
    }
    return checkBST(head->right);
}
// 
void process2(Node* head, vector<Node*> inOrderList){
    if(head == nullptr){
        return;
    }
    process2(head->left, inOrderList);
    inOrderList.push_back(head);
    process2(head->right, inOrderList);
}
bool checkBST2(Node* head){
    vector<Node*> inOrderList;
    process2(head, inOrderList);
    for(int i = 0; i < inOrderList.size() - 1; i++){
        if (inOrderList[i] >= inOrderList[i+1]){
            return false;
        }
    }
    return true;
}
// 非递归
bool checkBST3(Node* head){
    if(head != nullptr){
        int preValue = INTMAX_MIN;
        stack<Node*> s;
        while (!s.empty() || head != nullptr){
            if(head != nullptr){
                s.push(head);
                head = head->left;
            }
            else{
                head = s.top();
                s.pop();
                if(head->value <= preValue){
                    return false;
                }
                else{
                    preValue = head->value;
                }
                head = head->right;
            }
        }
    }
    return true;
}
```

**2. 如何判断一颗二叉树是完全二叉树**

[提示] 宽度优先遍历

(1) 任何一个节点，有右无左，返回false

(2) 在(1)不违规的条件下，如果遇到第一个左右子树不全的节点，后续节点必须都是叶节点
```cpp
bool isCBT(Node* head){
    if(head == nullptr){
        return true;
    }
    queue<Node*> q;
    // 是否遇到过左右两个孩子不全的节点
    bool leaf = false;
    Node* l = nullptr;
    Node* r = nullptr;
    q.push(head);
    while (!q.empty()){
        head = q.front();
        q.pop();
        l = head->left;
        r = head->right;
        if((leaf && (l != nullptr || r != nullptr)) 
            || (l == nullptr && r != nullptr)){
            return false;
        }
    }
    return true;
}
```

**3. 如何判断一颗二叉树是否是满二叉树**

[提示] 先求二叉树的最大深度L，再求二叉树的节点个数N

N = 2^L - 1
```cpp
class Info{
public:
    Info(int h, int n) : height(h),nodes(n){ }
    int height;
    int nodes;
};
Info f(Node* head){
    if(head == nullptr){
        return Info(0, 0);
    }
    Info leftData = f(head->left);
    Info rightData = f(head->right);
    int height = max(leftData.height, rightData.height) + 1;
    int nodes = leftData.nodes + rightData.nodes + 1;
    return Info(height, nodes);
}
bool isFBT(Node* head){
    if(head == nullptr){
        return true;
    }  
    Info data = f(head);
    return data.nodes == (1 << data.height - 1);
}
```

**4. 如何判断一颗二叉树是平衡二叉树**

树形DP（动态规划）
```cpp
class ReturnType{
public:
    ReturnType(bool isB, int hei) : isBalanced(isB), height(hei) { }
    bool isBalanced;
    int height;
};
ReturnType process(Node* head){
    if(head == nullptr){
        return ReturnType(true, 0);
    }
    ReturnType leftData = process(head->left);
    ReturnType rightData = process(head->right);
    int height = max(leftData.height, rightData.height) + 1;
    bool isBalanced = leftData.isBalanced && rightData.isBalanced 
                        && abs(leftData.height - rightData.height) < 2;
    return ReturnType(isBalanced, height);
}
bool isBalanced(Node* head){
    return process(head).isBalanced;
}
```

**5. 给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点**

node1 和 node2 一定属于head为头的树

方法一：
```cpp
void process(Node* head, unordered_map<Node*, Node*> fatherMap){
    if(head == nullptr){
        return;
    }
    fatherMap.insert(pair<Node*, Node*>(head->left, head));
    fatherMap.insert(pair<Node*, Node*>(head->right, head));
    process(head->left, fatherMap);
    process(head->right);
}
Node* lca(Node* head, Node* o1, Node* o2){
    unordered_map<Node*, Node*> fatherMap;
    fatherMap.insert(pair<Node*, Node*>(head, head));
    process(head, fatherMap);
    unordered_set<Node*> s;
    Node* cur = o1;
    while (cur != fatherMap.at(cur)){
        s.insert(cur);
        cur = fatherMap.at(cur);
    }
    s.insert(head);

    cur = o2;
    while (cur != fatherMap.at(cur)){
        if(s.find(cur) != s.end()){
            return cur;
        }
        cur = fatherMap.at(cur);
    }
    return head;
}
```

方法二：

(1) o1是o2的LCA，或o2是o1的LCA

(2) o1与o2不互为LCA
```cpp
Node* lowestAmcestor(Node* head, Node* o1, Node* o2){
    // base case
    if(head == nullptr || head == o1 || head == o2){
        return head;
    }
    Node* left = lowestAmcestor(head->left, o1, o2);
    Node* right = lowestAmcestor(head->right, o1, o2);
    if(left != nullptr && right != nullptr){
        return head;
    }
    return left != nullptr ? left : right;
}

```

**6. 在二叉树中找一个节点的后继节点**

[题目] 现在有一种新的二叉树节点类型如下

```cpp
class Node{
public:
    Node(int val) : value(val) { }

    int value;
    Node* left;
    Node* right;
    Node* parent;
};
```
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。

假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。

只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。

在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。

[提示]

(1) x 有右树时，右树上的最左节点

(2) x 无右树，往上走，判断当前节点是否是父节点的左孩子

(3) 整棵树最右侧的节点无后继节点
```cpp
Node* getLeftMost(Node* node){
    if(node == nullptr){
        return node;
    }
    while (node->left != nullptr){
        node = node->left;
    }
    return node;
}
Node* getSuccessorNode(Node* node){
    if(node == nullptr){
        return node;
    }
    if(node->right != nullptr){
        return getLeftMost(node->right);
    }
    else{
        Node* parent = node->parent;
        while(parent != nullptr && parent->left != node){
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}
```

**7. 二叉树的序列化和反序列化**

就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树

如何判断一颗二叉树是不是另一棵二叉树的子树？

```cpp
string serialByPre(Node* head){
    if(head == nullptr){
        return "#_";
    }
    string res = head->value + "_";
    res += serialByPre(head->left);
    res += serialByPre(head->right);
    return res;
}
Node* reconPreOrder(queue<string> q){
    string value = q.front();
    q.pop();
    if(value == "#"){
        return nullptr;
    }
    Node* head = new Node(stoi(value));
    head->left = reconPreOrder(q);
    head->right = reconPreOrder(q);
    return head;
}
Node* reconByPreString(string preStr){
    queue<string> q;
    int pos = preStr.find("_");
    while (pos != preStr.npos) {
        string temp = preStr.substr(0, pos);
        q.push(temp);
        preStr = preStr.substr(pos + 1, preStr.size());
        pos = preStr.find("_");
    }
    return reconPreOrder(q);
}
```

**8. 折纸问题**

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。

此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。

如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。

请从上到下打印所有折痕的方向。

例如：N=1时，打印：down。N=2时，打印：down down up 

```cpp
void printProcess(int i, int N, bool down){
    if(i > N){
        return;
    }
    printProcess(i+1, N, true);
    cout << (down ? "凹" : "凸") << " ";
    printProcess(i+1 , N, false);
}
void printAllfolds(int N){
    printProcess(1, N, true);
}
```

